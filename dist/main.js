(()=>{"use strict";let t=(r,e="",i=!0)=>{null!==r.right&&t(r.right,`${e}${i?"│   ":"    "}`,!1),console.log(`${e}${i?"└── ":"┌── "}${r.data}`),null!==r.left&&t(r.left,`${e}${i?"    ":"│   "}`,!0)};const r=class{constructor(t=null,r=null,e=null){this.data=t,this.left=r,this.right=e}};let e=new class{constructor(t){this.inputArray=[...new Set(t)].sort(((t,r)=>t-r)),this.root=this.buildTree(this.inputArray,0,this.inputArray.length-1),this.inorderData=[],this.preOrderData=[],this.postOrderData=[]}buildTree(t,e,i){if(e>i)return null;let l=parseInt((e+i)/2),h=new r(t[l]);return h.left=this.buildTree(t,e,l-1),h.right=this.buildTree(t,l+1,i),h}insert(e,i=this.root){return null==i?new r(e):(e<i.data?i.left=this.insert(e,i.left):i.right=this.insert(e,i.right),t(this.root),i)}delete(r,e=this.root){if(null==e)return e;if(r<e.data)e.left=this.delete(r,e.left);else if(r>e.data)e.right=this.delete(r,e.right);else{if(null==e.left)return e.right;if(null==e.right)return e.left;e.data=function(t){let r=t.data;for(;null!=t;)r=t.data,t=t.left;return r}(e),e.right=this.delete(e.right,e.data)}return t(this.root),e}find(t,r=this.root){return null==r||r.data==t?r:t<r.data?this.find(t,r.left):t>r.data?this.find(t,r.right):r}levelOrder(t=this.root){let r=[],e=[];if(null!=t){for(r.push(t);r.length>0;){let t=r.shift();e.push(t.data),null!==t.left&&r.push(t.left),null!==t.right&&r.push(t.right)}return e}}inorder(t=this.root){if(null!=t)return null!==t.left&&this.inorder(t.left),void 0!==t.data&&this.inorderData.push(t.data),null!==t.right&&this.inorder(t.right),this.inorderData}preOrder(t=this.root){if(null!=t)return void 0!==t.data&&this.preOrderData.push(t.data),null!==t.left&&this.preOrder(t.left),null!==t.right&&this.preOrder(t.right),this.preOrderData}postOrder(t=this.root){if(null!=t)return null!==t.left&&this.postOrder(t.left),null!==t.right&&this.postOrder(t.right),void 0!==t.data&&this.postOrderData.push(t.data),this.postOrderData}height(t=this.root){if(null==t)return-1;const r=this.height(t.left),e=this.height(t.right);return Math.max(r,e)+1}depth(t,r=this.root,e=0){if(null!=r)return r.data===t?e:t>r.data?this.depth(t,r.right,e+1):this.depth(t,r.left,e+1)}isBalanced(t=this.root){if(null==t)return!1;let r=t.left,e=t.right;return!(Math.abs(this.height(r)-this.height(e))>1)}rebalance(){const t=this.inorder();this.root=this.buildTree(t)}}([1,2,3,4,5,6,7]);console.log(e.inputArray),e.insert(8),console.log(e.root),console.log(e.height())})();